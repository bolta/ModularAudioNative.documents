article:
  title: groove について
  content:
    - |
      ここでは groove 機構について解説します。

      ですがその前に、まずは前提となるシーケンサと tick の関係について解説します。

      ## シーケンサと tick の関係

      シーケンサの動作は、イベントの一種である tick を契機としています。通常、tick は一定の時間間隔で発生しています。tick が発生する頻度は、テンポが速いほど、また ticksPerBar の値が大きいほど、それらに比例して密になります。

      <img src="./tempo_and_ticks.png" width=50%>

      tick の発生タイミングを制御しているのは **tick タイマー**という機構です。tick タイマーは小数値を保持するある種のカウンタであり、次のように動作します：

      * 初期値は 0
      * 保持する値を 1 サンプルごとに少しずつ増加させる。増加量はテンポと ticksPerBar に比例する

      そして、tick タイマーの値が整数値をまたいだ瞬間に tick が発生するようになっています（最初の tick は演奏開始の瞬間に発生します）。

      <img src="./tick_timer.png" width=50%>

      これが、tick が一定の時間間隔で発生するしくみです。

      ## tick と groove の関係

      そして groove は、tick タイマーの増加のペースに変調を加えます。
      
      groove は入力として tick タイマーの現在の値を受け取り、それに変換を加えた値を出力します。groove が制御する対象のトラックでは、本来の tick タイマーの代わりに、変調された値の系列を使うようになります。

      これにより、通常であれば一定間隔で発生する tick が、「訛って」発生するようになります。それは制御対象となるトラックの「ノリ」を変化させることになります。

      <img src="./modulated_tick_timer.png" width=50%>

      groove は、tick タイマーの値に対する関数として動作することから、変調を行う groove の定義を **groove 関数** とも呼びます（ModDL の言語仕様上の「関数」とは異なるのでご注意ください）。

      なお、tick タイマーは一定の値に達すると 0 にリセットされます。この一定の値を grooveCycle といい、文字通り groove の周期となります。

      ## ケーススタディ：跳ねたリズム

      ここで例題として、跳ねたリズム、つまり、本来等しい長さのはずの音符が、交互に長くなったり短くなったりするリズムを取り上げます。

      ここでは、16 分音符を 2:1 で跳ねさせてみます。つまり、`c16c16c16c16` が `c12c24c12c24` のように演奏されるようにします。

      まず、この跳ねたリズムの周期を考えます。連続する 16 分音符があるとき、最初のものは長く、次のものは短く、その次はまた長く…を繰り返すわけですから、周期は 16 分音符 2 つ分、つまり 8 分音符 1 つ分となります。これを tick 数に変換すると、(デフォルトでは ticksPerBar = 384 なので）tick 数は 384 / 8 = 48 です。したがって、grooveCycle を 48 とします。

      これにより、tick タイマーは 0 以上 48 未満の値を取ることになります。

      本来の tick は、tick タイマーがちょうど 0, 1, 2, ..., 47 となった、または超えた瞬間に発行されます。この tick タイマーの値に変調を加えることで、目標とするリズムを作り出します。

      ここで、x 軸に本来の tick タイマーの値、y 軸に変調後の tick タイマーの値をとったグラフを考えてみます。ここに描かれる曲線が groove 関数を表現しています。

      この関数は次の条件を満たす必要があります：

      * 2 点 (0, 0), (grooveCycle, grooveCycle) を必ず通る
      * 全ての点で単調増加である（水平な区間はあってかまわない）

      even なリズムであれば、本来の tick タイマーの値をそのまま使うわけですから、groove 関数は $y = x$ となります。

      では 2:1 で跳ねたリズムの場合、関数はどうなるでしょうか。

      周期の 48 ticks を 2:1 に分けるということは、長い方の 16 分音符の長さは本来の 32 ticks 分、短い方は本来の 16 ticks 分の時間をそれぞれ占めることになります。

      本来の 32 ticks 分の長さで、実際に発行される tick の数は 16 分音符 1 つ分、つまり 24 回であればよいわけですから、この関数は (32, 24) を通ればよいことになります。

      これに加えて groove 関数のグラフが必ず通るべき 2 点 (0, 0) および (grooveCycle, grooveCycle) = (48, 48) があるので、結局 3 点 (0, 0), (32, 24), (48, 48) を通ればよいことになります。これを満たす関数はいろいろありますが、単純な 1 次関数の場合分けで実現することにすると、

      * $0 \le x < 32$ のとき、  $y = \frac{24}{32}x$

      * $32 \le x < 48$ のとき、$y = \frac{24}{16}x - 24$

      となります（他にも 2 次関数で補間するなども考えられるので試してみてください）

      TODO グラフ

    -
      tips:
        - |
          グラフの大まかな見方として、$y = x$ を境として、右下側を通ると「ためた」リズムに、左上側を通ると「走った」リズムになることは覚えておくと便利でしょう。

    - |
      上の関数を `groove` 構築文で実装すると、次のようになります：

      ```
      @grooveCycle 48
      @groove ^G, ^a, =x=> if x < 32 // x < 0 や 48 <= x の値は来ないので考慮不要
          then (24 / 32) * x
          else (24 / 16) * x - 24
      ```

      先ほどの groove 関数は、さらに一般化することができます。n 分音符を r : (1 - r) で跳ねさせる groove 関数は以下のようになります：

      * $\mathrm{ticks} = \frac{\mathrm{ticksPerBar}}{n}$ として、
      * $0 \le x < 2r\mathrm{ticks}$ のとき、$y = \frac{1}{2r}x$
      * $2r\mathrm{ticks} \le x < 2\mathrm{ticks}$ のとき、$y = \frac{1}{2(1 - r)}x + \frac{1 - 2r}{1 - r}\mathrm{ticks}$

      これを関数を `groove` 構築文で実装すると、次のようになります：
      ```
      @let :ticksPerBar, 384
      @ticksPerBar ticksPerBar
      @grooveCycle 48

      @groove ^G, ^a,
        let n = 16;
        let r = 2 / 3;
        let ticks = ticksPerBar / n;

        // 余分な計算を減らすため式を少し変形
        =x=> if x < 2 * ticks * r
          then x / (2 * r)
          else x / (2 * (1 - r)) + (1 - 2 * r) / (1 - r) * ticks
      ```

      この `r` の値は、実は groove トラックの MML から変化させることができます。これにより、動的に変化する groove なども実現できます。

      ```
      @let :ticksPerBar, 384
      @ticksPerBar ticksPerBar
      @grooveCycle 48

      // groove 定義の r にラベルを付与している以外は上と同じ
      @groove ^G, ^a,
        let n = 16;
        let r = (2 / 3) @ r;
        let ticks = ticksPerBar / n;

        =x=> if x < 2 * ticks * r
          then x / (2 * r)
          else x / (2 * (1 - r)) + (1 - 2 * r) / (1 - r) * ticks

      // 4 小節経過後は even にする
      G [4 r1] yr,0.5

      // その 4 小節後からまた少し跳ねる（3:2）
      G [4 r1] yr,0.6
      ```
