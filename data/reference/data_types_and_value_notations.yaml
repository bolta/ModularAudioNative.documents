article:
  title: ModDL のデータ型と値の記法
  content:
    - |
      この文書では、ModDL の値のデータ型について説明します。

      また、各々の型の値の記法についても説明します。

      ## Number

      **数値**を表す型です。ModDL の数値は全て 32 ビット浮動小数点数です。

      ModDL では一般的な数値のほか真偽値についても数値で表し、真偽値のための独立した型はありません。真偽値としての数値の解釈では、**正の数値を真、負の数値と 0 を偽**とします。一般的なプログラミング言語の解釈とは異なるので注意してください。
      
      定数 `true`, `false` は、それぞれ真と偽を代表する値として `1`, `-1` と定義されています。

      ### 値の記法

      正負の整数・小数を、一般的な記法で記述することができます。ただし指数表記はありません。

      * `42`
      * `-3.14`

      ## Waveform

      **波形**を参照する型です。

      値は `waveform` 文によって定義され、変数に割り当てられます。

      ### 値の記法

      この型の値を直接表現する方法はありません。

      次のような `waveform` 文を記述すると、変数 `piano` で波形を参照できるようになります。

      ```
      @waveform :piano, "/path/to/piano.wav"
      ```

      ## TrackSet

      **トラックセット**を表す型です。トラックセットは、1 つ以上のトラックをまとめて表すものです。

      新しいトラックを定義するときと、定義したトラックを参照するときの両方で使います。

      ### 値の記法

      `^` に続いてトラック名（英数字 1 文字）を羅列して表します。

      * `^a`
      * `^678bcDE`

      それぞれ「トラック `a`」、「トラック `6`, `7`, `8`, `b`, `c`, `D`, `E`」を表します。

      ## QuotedIdentifier

      **識別子の引用形式**を表す型です。識別子に「変数」として割り当たった値ではなく、識別子の名前そのものを表します。

      `let` 文や `waveform` 文で変数を定義するとき、指定する変数名はこの型の値である必要があります。

      ### 値の記法

      識別子の前に `:` を付けて表します。

      識別子は ASCII の範囲で英数字と `_` を自由に組み合わせて作ることができます。ただし、最初の文字に数字を使うことはできません。大文字と小文字は区別されます。

      * `:foo`
      * `:barBaz345`

      次の `let` 文では `answer` という名前の変数を定義し、その値は `42` です：

      ```
      @let :answer, 42
      ```

      ## String

      **文字列**を表す型です。ファイルパスなどの表現に使います。

      ### 値の記法

      `"` ... `"` で任意の内容を囲んで表します。

      * `"./my_favorite_synths.moddl"`
      * `"hello, world"`

    - caution:
      - |
        `\` を使った特殊文字のエスケープには、現時点では対応していませんが、今後のバージョンでは対応を予定しています。したがって、
        
        * 文字列に `"` を含めることは、現時点ではできません。
        * ファイルパスの区切り文字には Windows 環境でも `/` を使うことを推奨します（文字列に含める `\` は将来 `\\` と書くことになる可能性が高く、非互換性の原因になります）。

    - |
      ## Array

      **配列**を表す型です。配列は、任意の型の値を 0 個以上の任意の数だけ、順序付きで並べたものです。

      配列に属する値を、配列の**要素**と呼びます。
      
      ModDL の配列では、各要素の型は統一されている必要はありません。

      配列の各要素は、先頭を `0` とする**添字**で指定して取り出すことができます。

      TODO 添字の構文について説明（というか実装も）

      ### 値の記法

      任意の数の要素を `,` で区切り、`[` ... `]` で囲んで表します。

      最後の要素の後にも冗長な `,` を付けることができます。

      * `[]`
      * `[1, 3, 5, ]`
      * ``[foo, ["bar", `baz`], ^qux]``

      ## Assoc

      **連想配列**（associative array）を表す型です。連想配列は、**キー**と**値**の組を 0 個以上の任意の数だけ、順序を定義せずにまとめたものです。

      連想配列に属するキーと値の組を**エントリ**と呼びます。

      キーは文字列でなくてはならず、また一つの連想配列の中で一意でなくてはなりません。値は任意の型の値にすることができます。値の型は統一されている必要はありません。

      連想配列に対しては、キーを指定して、対応する値を取り出すことができます。

      ### 値の記法

      任意の数のエントリを `,` で区切り、`{` ... `}` で囲んで表します。

      エントリは、キーと値を `:` で区切って表します。キーは識別子でなくてはならず、`"` ... `"` などで囲みません。

      * `{ }`
      * `{ foo: 42, bar: { baz: "qux" } }`

      TODO メンバアクセスの構文について説明

      ## NodeFactory

      **ノードファクトリ**を表す型です。

      ノードファクトリは、ModDL を実行する過程（より厳密には、演奏に先立つ「構築」の過程）においてノードに変換される値です。

      ノードファクトリにはパラメータを与えることができます。与えたパラメータは生成されたノードに設定されます。

      ### 値の記法

      ノードファクトリそのものを ModDL で記述することは（現時点では）できず、組み込み変数として提供されているものを使うことになります。

      組み込みのノードファクトリの一部を挙げると、以下のようなものがあります：

      * オシレータ
        * `sineOsc`, `sawOsc`, `pulseOsc`
      * フィルタ
        * `lpf`, `hpf`, `bpf`
      * エンベロープ
        * `expEnv`, `adsrEnv`

      ノードファクトリにパラメータを与えるには、ノードファクトリの値の後に `{` ... `}` で囲んだパラメータを記述します。パラメータは名前と値を `:` で区切ったものです。

      ```
      lpf { freq: 3000, q: 10 }
      ```

      ノードファクトリにパラメータを与えたものは、後述の NodeStructure 型の値になります。

      #### パラメータとパラメータ名の省略

      TODO こういう細かい話は他でやった方がいい？

      ノードファクトリの種類に応じて、パラメータの名前、順番、デフォルト値（必須パラメータの場合を除く）が決まっています。パラメータを先頭から順番通りに設定する場合は、パラメータ名を省略することができます。

      たとえば `adsrEnv` のパラメータは順に `attack`（デフォルト値は `0`）, `decay`（`0`）, `sustain`（`1`）, `release`（`0`）, `initial`（`0`） です。このため、次の 2 つは同じ意味になります：

      ```
      adsrEnv { attack: 0.2, decay: 0.5, sustain: 0.8 }
      adsrEnv { 0.2, 0.5, 0.8 }
      ```

      `release` と `initial` には値が設定されていないため、それぞれデフォルト値の `0` が適用されます。

      一方、パラメータの名前を明示すれば、必要なパラメータだけを自由な順番で設定することができます。次の例では `decay` と `release` だけを設定します（それ以外はデフォルト値が適用されます）：

      ```
      adsrEnv { release: 1, decay: 0.5 }
      ```

      さらに、パラメータ名の省略と明示を組み合わせることもできます。たとえば次のような書き方も可能です：

      ```
      adsrEnv { 0.5, 1, initial: 0.7, release: 0.5 }
      ```

      この例では `0.5` は `attack`、`1` は `decay` に適用されます。`sustain` はデフォルト値の `1` になります。

      ### ノードファクトリとノードの関係

      ノードファクトリはノードそのものではなく、ノードの**素**であり、そこからノードが（いくつでも）生成される存在です。ノードファクトリとしては 1 つの値でも、式の中で何度も使われれば、その都度異なるノードが生成されます。

      たとえば、次の式には同じ `sineOsc` が 3 回使われていますが、ModDL が処理される過程で全て別々のノードになります。

      3 つのオシレータにそれぞれ異なる周波数が入力され、結果として加算合成を実現することができます。

      ```
      f | sineOsc \
      + (2 * f) | sineOsc / 2 \
      + (3 * f) | sineOsc / 3
      ```

      なお、ModDL の中でノードそのものを扱う方法はありません。ノードの構築は、ModDL を処理して得られた（ノードファクトリを含む）ノード構造に基づいて、ModDL の外側の世界で行われるため、ModDL を処理する段階においてノードはまだ存在しないためです。

      ## NodeStructure

      **ノード構造**を表す型です。ノード構造とは、ノードの接続関係などを表すものです。

      TODO blah blah

    

      ## Function

      **関数**を表す型です。関数は引数として任意の個数の値を取り、評価結果として 1 つの値を返します。

      ModDL の関数は**純粋関数**であり、副作用を持つことがありません（さらに言えば ModDL は純粋な言語であり、関数に限らずどんな方法でも副作用を生じさせることはできません）。

      ### 値の記法

      関数は組み込みとして提供されているほか、新たに定義することもできます。

      組み込みの関数の一部を挙げると、以下のようなものがあります：

      * 数学関数
        * `sin`, `log`, `round`
      * 高階関数
        * `map`, `reduce`
      * モジュールシステムに関する関数
        * `import`

      新たな関数を記述するには、引数とする識別子を `,` で区切って `(` … `)` で囲んだあと、`=>` に続けて値を記述します。

      たとえば、与えられた 2 つの値を掛け合わせる関数は、次のようになります：

      ```
      (x, y) => x * y
      ```

      引数が 1 つだけの場合は、`(`, `)` を省略することができます：

      ```
      x => x ^ 2
      ```

      これらはいわゆる「無名関数」の記法ですが、ModDL では「名前のある関数」を定義する方法は別段提供していません。名前のある関数は、無名関数を `let` 文や `let` 式で変数に割り当てれば作ることができます（再帰もできます ← TODO `let` 文・式ともできるよね……確認しておく）。

      ```
      @let :multiply, (x, y) => x * y
      @let :answer, multiply(6, 7) // 42
      ```

      ちなみに引数が 0 個の関数を作ることも可能ですが、純粋な言語において「引数を取らない関数」は定数と同じなので、基本的に作る意味はありません。ただし、評価を遅延する（時間のかかる計算を定義はしておくが、必要になるまでは計算を実行しない）目的では、使い途があるかもしれません。

      ```
      @let :calcAnswer, () => 42
      @let :answer, calcAnswer() // 直接 42 と定義するのと同じ
      ```

      関数を評価するときは、上記の例ですでに出ていますが、関数の後に `(` … `)` を続け、引数として `,` で区切った値を指定します。ノードファクトリの引数と同様に、引数の名前を明示することもできます。

      なお、関数評価には糖衣構文があります。組み込み関数 `map` は、第 1 引数に配列を取り、その全ての要素に第 2 引数の関数を適用します。したがって通常の書き方では以下のようになりますが：

      ```
      map([0, 1, 2, 3, 4], x => x ^ 2) // [0, 1, 4, 9, 16]
      ```

      これを次のように書くこともできます：

      ```
      [0, 1, 2, 3, 4]~map(x => x ^ 2)
      ```

      記号 `~` を使った構文では、関数と第 1 引数の順番が入れ替わります。これにより一般的なオブジェクト指向言語のように、`map` が配列に属する**メソッド**であるかのように記述することができます。

      これは単なる糖衣構文なので、1 つ以上の引数を取る全ての関数に適用できます。前出の multiply を次のように書くことも可能ではあります：
      ```
      @let :answer, 6~multiply(7) // 42
      ```

    -
      tips: |
        文章校正で、隣り合った文字や単語を入れ替えることを表す記号が `~` に似ていることから、この記号を採用しています。

    - |


      ## Io

      TODO blah blah blah blah blah

    #       -
    #         - NodeStructure
    #         - |
    #           ノード構造。ノードの接続関係を記述したものです。

    #           TODO 推敲 ~~ModDL に記述したノード構造は、演奏時に実際のノードとして構築されます。
    #           ModDL でノードそのものを記述することはできません。
    #           blah blah~~

    #         - |
    #           * `sineOsc`
    #           * `node (f) uniformNoise | lpf { cutoff: f } * adsrEnv { attack@a: 0.5 }`
    #       -
    #         - NodeFactory
    #         - ノードファクトリ。
    #         - |
    #           * sineOsc

    #       -
    #         - Function
    #         - 関数。
    #         - |
    #           * `map`
    #           * `(x, y) => x * y`
    #           * `x => x ^ 2`
