article:
  title: インストゥルメントについて
  content:
    - |
      ここではインストゥルメントについて解説します。

      インストゥルメントは特別な役割を持ったモジュールの一種であり、その名の通り「楽器」に相当するものです。インストゥルメントは ModDL で楽曲を演奏する上で不可欠の存在です。

      インストゥルメントに要求される機能は、周波数の時系列を入力として受け取り、波形を出力することです。さらに、送られてくる Note イベントを処理することも求められます。
      
      インストゥルメントを定義するには `@instrument` 構築文を使います。定義したインストゥルメントは MML を使って演奏することができます。

      ## 最も単純なインストゥルメント

      インストゥルメントは周波数から波形を生成すると述べましたが、この機能はまさにオシレータと同じです。ということは、オシレータを 1 つ置くだけで、「ほぼ」インストゥルメントです。

      ```
      @instrument ^a, sawOsc
      ```

      「ほぼ」と言ったのは、まだ少し足りないからです。これでは音が鳴りっぱなしになってしまいます。たとえば MML の `r` コマンドや `q` コマンドで音を切ったとき、思ったように音が切れてくれない結果になります。

      そこで、エンベロープを追加します。エンベロープは Note イベントに反応して、音を出したり止めたりしてくれます。こうなれば、文句なしにインストゥルメントの条件を満たしていると言うことができます。

      ```
      @instrument ^a, sawOsc * adsrEnv
      ```

    - note: 
      - |
        オシレータにエンベロープを適用するには、オシレータの出力に対してエンベロープの出力を**乗算**します。

        次のように、オシレータの出力をエンベロープの入力に**接続**するのではありません：

        ```
        // 音が出ない
        @instrument ^a, sawOsc | adsrEnv
        ```

    - note: 
      - |
        `adsrEnv` は 5 つのパラメータ入力を取りますが、ここでは全て省略してデフォルトのまま使っています。これだけでも note on/off を処理してくれます。

    - |
      ## エフェクトを適用する


      TODO エフェクトを適用する

      TODO   フィルタ

      TODO   ディレイ

      TODO   歪み

      TODO このように単一のインストゥルメントに対して作用するエフェクトはインストゥルメントの一部として定義してしまえる

      TODO 複数トラックにまたがるエフェクトを定義するには `@effect` 構築文が必要になる。これは別途

      ## もう一種類のエフェクト：周波数エフェクト

      最初に述べたように、インストゥルメントは必ずどこかで周波数を波形に変換するようになっています。

    - note:
      - |
        ノイズのように、入力周波数を無視するインストゥルメントも考えられますが、ここでは考えないことにします。

    - |
      ということは、インストゥルメントの内部には周波数が波形に変換される「ある点」があり、インストゥルメントはそこを境に、周波数を扱う領域と、波形を扱う領域の 2 つに分かれているはずです。

      「ある点」とは端的に言えばオシレータですが、これまで作ってきたインストゥルメントは全て最初にオシレータがあったので、周波数を扱う領域には何もなく、全てのエフェクト（エンベロープも含む）はオシレータが出力した波形に対して作用していました。

      しかし、周波数を扱う領域にエフェクトを挿入することもできるはずです。

      実際、そんなエフェクトを作ることができます。波形に変換される前の、周波数の段階で適用するエフェクトなので、このようなエフェクトを**周波数エフェクト**（またはピッチエフェクト）と呼ぶことにします。

      ここからは周波数エフェクトの例をいくつか紹介していきます。

      ### 移調

      入力周波数とは違うキーでインストゥルメントを演奏できると便利な場合があります。全てのインストゥルメントに適用すれば、カラオケのように曲全体を移調することも可能になります。

      音は周波数が 2 倍になると 1 オクターブ高くなる性質があります。したがって 1 オクターブ上に移調したい場合は（この場合「調」は変わらないのであまり移調とはいいませんが…）、入力周波数を 2 倍してやればよいことになります。

      ```
      @instrument ^a, (=f=> 2 * f) | sawOsc * adsrEnv
      ```

    - note:
      - |
        入力された周波数を明示的に扱うため、入力参照構文が必要になります。

    - |
      2 倍ではなく 1.5 倍にすれば、（平均律の音程とは少し異なりますが）完全 5 度上げることができます。

      ```
      @instrument ^a, (=f=> 1.5 * f) | sawOsc * adsrEnv
      ```

      一般には、平均律において周波数を $2^{\frac{s}{12}}$ 倍すれば、半音 $s$ 個分上げることができます（ついでに移調を行うモジュールを変数に切り出しています）。

      ```
      @let :s, 3 // 上げる幅を半音単位で指定する
      @let :transpose, =f=> 2 ^ (s / 12) * f
      @instrument ^a, transpose | sawOsc * adsrEnv
      ```

      このように、オシレータよりも手前にエフェクトを挿入すれば、それは周波数エフェクトとなります。

      ### ビブラート

      オシレータの周波数を、別の遅いオシレータ（LFO）で変調させることでビブラートを表現するのは、シンセサイザの定番です。これをやってみましょう。

      今回、ビブラートの速さを 5 Hz、深さ（本来の周波数からの変位の振幅）を 20 Hz とします。まずは周波数 5 Hz の正弦波（またはお好みで他の波形）を定義します：

      ```
      @let :lfo, 5 | sineOsc
      ```

      これを、インストゥルメントに入力された周波数に振幅 20 で加えてやります：

      ```
      // オシレータの元の振幅が 2 なので、振幅 20 にするには 10 倍する
      @instrument ^a, (=f=> f + 10 * lfo) | sawOsc * adsrEnv
      ```

    - note:
      - |
        この方法では、ビブラートの深さは入力周波数が低いほど深く、高いほど浅くなります。音域に依らず均等にビブラートをかけたい場合は、`lfo` を入力周波数に加算ではなく乗算で適用する必要があります。

    - |
      ### グライド

      グライドはポルタメントとも呼ばれています。グライドは標準ライブラリに `glide` として含まれています。

      グライドは、入力周波数が一定のときはそのまま出力しますが、入力周波数が変化したときに、新しい入力周波数をすぐには出力に反映せず、入力に出力をゆっくり近づけていきます。

      モジュール定義 `glide` は、パラメータ入力として「半減期」（half-life）を取るようになっています。単位は秒であり、入力周波数が $f_1$ から $f_2$ に変化したとき、出力周波数が $\frac{f_1 + f_2}{2}$ に達するのにかかる時間を指定します。

      半減期という単語からわかるように、出力周波数は指数的に変化します。このため厳密には入力と出力が完全に等しくなることは永久にないのですが、聴覚上、また計算精度上、「そのうち」等しくなると考えて問題はありません。

      ```
      @instrument ^a, glide { halflife: 0.1 } | sawOsc * adsrEnv
      ```

      ### その他

      通常は波形エフェクト（いわゆる普通のエフェクト）であるものを周波数エフェクトに使い回すと、様々な可能性があるはずです。

      たとえば周波数に `adsrEnv` を適用すると、癖のあるピッチ変化を実現できるはずです。これはドラム音などの表現に有用かもしれません。

      君だけの周波数エフェクトを作ろう！
