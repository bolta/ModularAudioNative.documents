article:
  title: 波形について
  content:
    - |
      ModDL は任意の波形を再生する機構を備えています。これを使うと、オシレータやフィルタを駆使して望みの音色（波形）を得る代わりに、任意の波形を使ってあらゆる音色を直接表現できるほか、音色以外への応用も可能です。

      波形はファイルから読み込むほかに、ソースコード上で直接記述することもできます。

      ModDL で波形を使うには、まず波形をシステムに登録し、その後登録した波形を再生する、という手順を踏みます。それぞれの手順を以下で解説します。

      また、音色以外への応用についても解説します。

      ## 波形の登録

      波形をシステムに登録するには、`@waveform` 構築文を使います。

      波形をファイルから読み込むかソースコード上で直接記述するかによって、`@waveform` 文の書き方が異なります。

      ### 波形をファイルから読み込む

      たとえば、`my_favorite_waveform.wav` の波形を読み込むには次のようにします：

      ```
      @waveform :wave, "./path/to/my_favorite_waveform.wav"
      ```

      ここで `:wave` とあるのは、読み込んだ波形を参照するための変数です。変数 `wave` には `my_favorite_waveform.wav` の波形を参照する Waveform 型の値が割り当たり、その波形を指すのに使えるようになります。

      このように、波形の登録は変数の定義を兼ねることになります。したがって構文が `@let` 文と似ています。

    - note:
      - |
        バージョン 0.1.0 現在、読み込めるファイルの形式は量子化レートが 8 または 16 ビット、チャンネル数が 1 ～ 2 の wav ファイルだけです。

        また、ステレオのファイルを読み込んでも左チャンネルだけがモノラルで再生されます。

    - |
      読み込んだ波形の振幅は、wav ファイルのフォーマットで表せる最も小さな値と最も大きな値が [-1, 1) の範囲に収まるよう正規化されます。すなわち、量子化レートが 16 ビットの場合、値の範囲は [-32768, 32767] であるため、読み込みの際 [-1, 1) に収まるように全てのサンプルが 32768 で割られます。同様に量子化レートが 8 ビットの場合は値のサンプルが [-128, 127] であるため、全てのサンプルが 128 で割られます。

      ### 波形を直接記述する

      波形をソースコード上で直接記述する場合は、`@waveform` 文に次のような連想を記述します：

      ```
      @waveform :wave, {
        data: [ /* 波形を表す数値配列 */ ],
        sampleRate: /* サンプルレート */,
      }
      ```

      `data` は波形の 1 つ 1 つのサンプルを並べた数値の配列です。`sampleRate` は、1 秒間にいくつのサンプルを再生するかの数値で、単位は Hz です。たとえば `sampleRate` が 44100 の場合、`data` の一つ一つの値の有効時間は 1/44100 秒となります。

    - note:
      - |
        バージョン 0.1.0 現在、ステレオの波形を記述することはできません。モノラルの波形のみ記述できます。

    - |
      wav ファイルの内容は、一言で言えば数値の配列とサンプルレートの組なので、それらを上記のように記述すれば情報としては等価なわけです。

      したがって、先ほどの `my_favorite_waveform.wav` の内容をここに直接記述することも可能ですが、それは（少なくとも手で記述するのは）現実的ではありません。なにせ、サンプルレートを 44100 Hz、波形の長さを 0.5 秒とすると 22050 個の数値を書かなければならないのです。

      `data` を手書きする目的は別のところにあります。その一つは、波形メモリ音源のような、少ないサンプルから成る波形を再生する機構を再現することです。

      たとえば、`data` を次のように手書きすれば、ごく粗い三角波の 1 周期分を表現することができます。`sampleRate` を決めなければなりませんが、これは後回しにします：

      ```
      @waveform :wave, {
        data: [0, 1, 2, 3, 2, 1, 0, -1, -2, -3, -4, -3, -2, -1],
        sampleRate: /* サンプルレート */,
      }
      ```

      波形を手書きする場合、wav ファイルを読み込む際のような正規化は行われないので、正規化は自分で行ってやる必要があります。

      先ほどの例では、サンプルが [-4, 4) の範囲に分布しているので、全てのサンプルを 4 で割ることで [-1, 1) に正規化することができます：

      ```
      @waveform :wave, {
        data: [0, 1, 2, 3, 2, 1, 0, -1, -2, -3, -4, -3, -2, -1]~map(s -> s / 4),
        sampleRate: /* サンプルレート */,
      }
      ```

      ### 波形をループさせる

      波形はループさせて再生することができます。上記では三角波の 1 周期分を記述しましたが、実際にはこれを繰り返さないと三角波になりません。そこでループを設定します。ループの設定は、`@waveform` 文で波形を登録する際に行います。

      ループとは、波形の再生位置が「ある位置」に達したら、「ある位置」まで戻すことです。前者の位置を `endOffset`、後者の位置を `loopOffset` と呼び、単位はサンプル（先頭を 0 として、そこからのサンプル数）です。当然 `loopOffset` < `endOffset` です。

      今回、波形全体を繰り返せばよいので、`endOffset` は波形のサンプル数である 14、`loopOffset` は 0 となります。これらを波形の記述に加えます：

      ```
      @waveform :wave, {
        data: [0, 1, 2, 3, 2, 1, 0, -1, -2, -3, -4, -3, -2, -1]~map(s -> s / 4),
        sampleRate: /* サンプルレート */,
        endOffset: 14,
        loopOffset: 0,
      }
      ```

      ただし、よいプログラマの皆さんは 14 という即値を書くことを好みません。意図が不明瞭になることに加え、今後もし配列の長さが変わると対応できないからです。解決方法としては、次のように配列を先に定義することで `endOffset` の直書きを避ける手もありますが：
      ```
      @let :data, [0, 1, 2, 3, 2, 1, 0, -1, -2, -3, -4, -3, -2, -1 ]~map(s -> s / 4)
      @waveform :wave, {
        data: data,
        sampleRate: /* サンプルレート */,
        endOffset: data~count(),
        loopOffset: 0,
      }
      ```

      もっといい方法があります。ループさせたい部分を入れ子の配列にすると、ループとして解釈されるのです。このとき `endOffset`, `loopOffset` の記述は不要になります：
      ```
      @waveform :wave, {
        data: [[0, 1, 2, 3, 2, 1, 0, -1, -2, -3, -4, -3, -2, -1]]~waveMap(s -> s / 4),
        sampleRate: /* サンプルレート */,
      }
      ```

      今回、`data` 全体が 2 重の配列になっています。これは配列の全体をループさせることを意味します。

      また、`map` が `waveMap` に換わっています。`waveMap` は入れ子の配列の構造はそのままに、全ての数値に対して関数を適用します。

      波形をループさせたい場合は、上記のように配列の全体が 2 重になるか、`[0, 1, [2, 3, ...]]` のように途中から 2 重になりますが、このような場合 `map` を単純に使っただけでは全ての数値を正しく処理できません。こんなときでも `waveMap` はうまくやってくれ、`[0, 1, [2, 3, ...]]~waveMap(s -> s / 4)` の結果は `[0, 0.25, [0.5, 0.75, ...]]` となります。

      当然、入れ子がなくても、常に `waveMap` を使って問題ありません。

      ### 手書き波形のサンプルレートを決める

      先ほど後回しにしたサンプルレートについて説明します。

      サンプルレートは、波形を wav ファイルから読み込む場合は wav ファイル内に記載されていますが、波形を手書きする場合は明示的に指定する必要があります。それについては後回しにしていましたが、ここでその求め方を説明します。

      前提として、ModDL で波形を演奏する際に基準となる音高は `o4c` となっています。`o4c` の周波数は次のように求められ、値は約 261.63 Hz です：

      ```
      // o4a = 440 Hz から 9 半音下げる
      @let :o4c, 440 * 2 ^ (-9 / 12)
      ```

      1 秒間に波形の周期をこの回数だけ繰り返せば、`o4c` の音高が得られることになります。

      さて、サンプルレートとは、こちらも単位は周波数と同じ Hz ですが、こちらは「波形の周期」ではなく「サンプル」が、1 秒間に何個あるかを示すものです。したがって、上で求めた `o4c` の周波数に、さらに波形 1 周期あたりのサンプル数をかけてやれば、サンプルレートが求まることになります。

      波形に含まれるループのサンプル数を求めるために `waveLoopLength()` 関数が用意されています。これを使ってサンプルレートを求めるコードは以下のようになります（値は約 3662.76 Hz となります）：

      ```
      @waveform :wave,
        let data = [[0, 1, 2, 3, 2, 1, 0, -1, -2, -3, -4, -3, -2, -1]]~waveMap(s -> s / 4);
        {
          data: data,
          sampleRate: o4c * data~waveLoopLength(),
        }
      ```

    - note:
      - |
        TODO 波形配列の短縮記法について

    - |
      ### 基準の音高を変更する

      TODO

      ## 波形の再生

      システムに登録した波形を再生するには、`waveformPlayer` ノードを使います。

      ただし、`waveformPlayer` はノード定義ではなく関数であり、引数で再生する波形を指定して、ノード定義を得るようになっています。

      wav ファイルから波形を読み込み、`waveformPlayer` で再生するためのコードは次のようになります（もちろん手書きの波形でも同様の方法で再生できます）。`waveformPlayer` は note on で波形を先頭から再生しますが、note off では止まらないので、音を止めるためにはエンベロープが必要になる点は注意してください。

      ```
      @waveform :wave, "./path/to/my_favorite_waveform.wav"
      @instrument ^a, waveformPlayer(wave) * adsrEnv
      ```

    - note:
      - |
        note off で波形の再生が止まらないのは、エンベロープにリリースがある場合（たとえば `adsrEnv` で `release` > 0 の場合）、note off で再生を止めてしまうとリリース部分が発音されなくなってしまうためです。

        これはオシレータが note off を関知しないのと一貫しています。

    - |
      `waveformPlayer` は再生する波形を演奏中に切り替えることができます。方法は以下の通りです：

      1. `waveformPlayer` に `@` 演算子でレジスタを割り当てます。
      2. 割り当てたレジスタに対して MML の `y` コマンドで Waveform 型の値を設定します。設定する値には `= ;` 構文を使い、Waveform 型の変数を参照します。

      ```
      @waveform :wave1, "./path/to/my_favorite_waveform.wav"
      @waveform :wave2, "./path/to/my_other_favorite_waveform.wav"
      @instrument ^a, waveformPlayer(wave1)@w * adsrEnv

      a o4l8v15
      a cdefg2
      a yw,=wave2;
      a cdefg2
      ```

      ## 波形の応用

      ここまでの波形の使い方は、音色を表現するためのものでした。言葉を換えれば、波形をオシレータの代わりとして使ってきました。
      
      しかし、波形の使い途はそれだけではありません。

      ### 波形を使ったエンベロープ

      次の例では、波形を使ってエンベロープを表現しています。その形状は、既存のエンベロープジェネレータで実現することは困難と思われる複雑なものです：

      ```
      @let :o4c, 440 * 2 ^ (-9 / 12)

      @waveform :env, {
        data: x[fdb9fdb9fdb9fdb9[5]]~waveMap(x -> x / 15),
        sampleRate: 60,
      }
      @instrument ^a, pulseOsc * o4c | waveformPlayer(env) * adsrEnv

      a o2l2v15 q4
      a c>c>c>c>c>c>c
      ```

      注目すべき点がいくつかあります。

      まず、波形の `sampleRate` を 60 としつつ、`waveformPlayer` に供給する周波数は基準である `o4c` に固定しています。これにより、エンベロープの波形はオシレータに与えられる周波数とは関係なく一定の速度（60 fps）で再生されます。

    - note:
      - |
        逆に、エンベロープの再生速度にあえてオシレータの周波数を作用させるような構成も可能です。こうすると、たとえば「低い音ほど長く、高い音ほど短くなる」など、音の高さに依存してエンベロープを変化させることができます。

    - |
      また、`waveformPlayer` によるエンベロープとは別に、「本物」のエンベロープ、`adsrEnv` も使っています。これは先にも述べたように、`waveformPlayer` には音を止める能力がないためです。ここでの `adsrEnv` は note off で音を止めるためだけに使われています。

    - note:
      - |
        ちなみにこの構成は、`waveformPlayer` を使ったリングモジュレーションと解釈することもできます。`waveformPlayer` の出力が可聴域内の周波数を持つ周期的なものであれば、リングモジュレーションの効果が得られるはずです。

        エンベロープとリングモジュレーションは、その構成としてはほぼ同じであるにもかかわらず、得られる効果が全く違うのは興味深いことです。
  
    - |
      ### 波形を使った周波数エフェクト

      次は、波形を使った周波数エフェクトの例です。こちらも挙動は複雑で、アタックの後しばらく経ってからビブラートがかかり、その後ビブラートは次第に深くゆっくりになります：

      ```
      @let :o4c, 440 * 2 ^ (-9 / 12)

      @let :bend, semi -> =f=> f * 2 ^ (semi / 12)
      @waveform :vib, {
        data: x[00000000000000000000 10<10>1210<1210>123210<123210>[12343210<12343210>]],
        sampleRate: 60,
      }
      @instrument ^a, bend(0.1 * o4c | waveformPlayer(vib)) | pulseOsc { duty: 0.25 } * adsrEnv { 0.2 }

      a o2l1v15
      a c>c>c>c>c>c>c
      ```

      先に定義している `bend` は、半音単位で周波数を変調する周波数エフェクトですが、その変調の大きさを `waveformPlayer` で制御しています。係数 `0.1` をかけることで、波形における 1 の変位が 0.1 半音（10 セント）の変調になるようにしています。

    - note:
      - |
        こちらも `WaveformPlayer` を使った周波数変調（FM）と解釈することもできます。

        ビブラートと周波数変調も、やはり構成的には同じものです。
