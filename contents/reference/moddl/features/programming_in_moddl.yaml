article:
  title: ModDL によるプログラミング
  content:
    - |
      ModDL の最終的な目的はモジュール定義とシーケンスを構築することですが、そのために役立つツールとして、プログラミング言語の機能を備えています。

      プログラミング言語としての ModDL のスタイルは、関数を値として取り回すことを許し、変数の値や環境を変更することを許さない、純粋関数型言語のスタイルです。

      ここでは ModDL のプログラミング言語としての側面を解説していきます。

      ## 文

      ModDL のソースファイルは**文**を並べたものであり、文は構築文と MML 文の 2 種類から成っています。

      **構築文**は `@` で始まる文であり、音楽を演奏するために必要な構造や設定を定義します。

      **MML 文**はトラック名と MML から成る文であり、指定したトラックの時間的なふるまい（いわゆる「譜面」）を定義します。

      以下で説明するプログラミング言語としての機能は、これらのうち主に構築文と密接に関連しています。

      MML については「%link(../../mml/toc)」で詳細に説明します。

      文と文の境界は、行末です。ただし、一定の条件下で複数行にまたがって文を続けることができます。

    -
      note: |
        複数行にまたがって文を続けられるのは、概ね以下の場合です：

        * 構文上、行末が文の途中であることが明らかな場合。たとえば行が `,` や `+` などで終わっている場合
        * 行末に `\` が置かれている場合

    - |
      ## コメント

      コメントはプログラムの動作には一切影響しません。コメントには以下の 2 種類があります：

      * `//` から行の終わりまでは**行コメント**となります。
      * `/*` から直近の `*/` までは**範囲コメント**となります。範囲コメントは複数行にまたがることができます。

      ## データ型

      ModDL も多くのプログラミング言語に備わっている数値（Number）、文字列（String）、配列（Array）、関数（Function）などの基本的なデータ型を備えています。

      一方、ModDL に特有のデータ型としては波形（Waveform）やトラックセット（TrackSet）、そしてモジュール定義（ModuleDef）があります。これらは全て発音や演奏の目的に特化した型です。なお、「モジュールの構築」で示したモジュール定義の例は、全てモジュール定義型の式です。

      データ型の詳細については「（TODO）」を参照してください。

      ## データ構造

      ModDL は、データ構造を構築するためのデータ型として、配列（Array）と連想（Assoc）を備えています。

      配列は `0` から始まる整数の添字に任意の型の要素を関連づけます。

      連想は文字列のキーに任意の型の値を関連づけます。キーの順序は定義されません。

      いずれも、異なる型の要素・値を混在させることができます（heterogeneous）。またそれを禁じることは（言語レベルでは）できません。

    - note:
      - |
        「連想」（Assoc）は「連想配列」（Associative Array）を省略したものであり、「連想配列」の名称はプログラミング言語 AWK から借用したものです。

        他の言語では同様のデータ型が「ハッシュ」（Hash）、「マップ」（Map）、「辞書」（Dictionary）などと呼ばれていますが、いずれも多義的になりがち（ハッシュ値、map 関数、自然言語の辞書）であったり、「ハッシュ」については実装を規定しすぎるなどの問題があるように思われます。

        その点「連想配列」は余計な含みがなく、誤解の恐れがない点で優位ですが、唯一の難点は少し長いことです。

        そこで省略形を採用しています。

    - |
      ## 変数

      ModDL にはスコープの異なる 2 種類の変数があります。1 つはファイルスコープ変数で、定義以降のファイル中の任意の場所から参照できます（ローカル変数で隠された場合を除きます）。もう 1 つはローカル変数で、定義した個所からその式の終わりまでの間だけ参照できます。

      ファイルスコープ変数は、構築文 `@let` または `@letAll` で定義します。一方ローカル変数は、式の中で `let` 式を使って定義します。

    - note:
      - |
        ファイルスコープ変数がローカル変数で隠されるのは、次のような場合です：

        ```
        @let :foo, 42
        @let :bar,
          let baz = foo; // baz = 42
          let foo = 100; // foo = 42 を隠す
          foo // bar = 100
        @let :qux, foo // qux = 42
        ```

    - |
      いずれの変数も定義後に値を変更することはできません。

      ModDL の変数には型がありません。変数の型は明示的に記述されることも、暗黙的に推論されることもありません。ただし、全ての変数には強く型付けられた値が割り当てられ、その割り当てが後から変更されることはないため、その意味ではある変数に対応する型は終始一貫しています。

      ## 関数

      関数を定義する方法は、`(x, y) -> sqrt(x ^ 2 + y ^ 2)` のような、いわゆる無名関数のみです。名前のついた関数を定義するには、無名関数を値とする変数を定義します。

      ```
      @let :dist, (x, y) -> sqrt(x ^ 2 + y ^ 2)
      @let :d, dist(3, 4) // d = 5
      ```

      関数を引数に適用するには、上記のように関数型の値に `(` ... `)` で引数を指定します。

      なお、関数の適用にはもう一つの構文があり、通常であれば `f(a1, a2, ...)` であるところ、関数の最初の引数を先頭に書いて `a1~f(a2, ...)` のようにすることができます。`f` が `a1` が持つ**メソッド**のように見えるので、この記法を（関数適用の）**メソッド記法**と呼びます。

      たとえば、次の 2 つは同じ意味になります：
      ```
      // 通常の記法
      map([0, 1, 2, 3, 4], x -> x ^ 2)

      // メソッド記法
      [0, 1, 2, 3, 4]~map(x -> x ^ 2)
      ```

      この書き換えは常に可能です。したがって前述の `dist(3, 4)` を `3~dist(4)` のように書くことも、意味があるかは別にして、可能ではあります。

    -
      note: |
        メソッド記法とは、つまりは関数とその先頭の引数の順序を入れ替える記法です。文章校正で隣り合った文字や単語を入れ替えることを表す記号が `~` に似ていることから、この記号を採用しています。

    - |
      ## 制御構造

      関数型言語である ModDL には、手続き型言語で一般的な `while` や `for` などの制御構造はありません。

      代わりに、高階関数である `map`, `filter`, `reduce` 等を使うことで、制御構造と同等の処理を行えるようになっています。

      `if` については文ではなく式として存在します。条件が成り立つ場合と成り立たない場合とで式の値が変わります。どちらの場合も値が必要なので、`else` 節は省略できません。

      ## ファイル分割

      よく使うモジュール等を別のファイルに切り出して、複数のファイルから参照することができます。

      `@export` 構築文を使うと、任意の値を他の ModDL ファイルに対して公開することができます。

      公開した値は、他の ModDL ファイルから `import` 関数で取り込むことができます。

#     Io の説明は後からでも

#       ## Io
# 
#       ### Io とは
# 
#       先に少し触れた通り、ModDL では変数や環境の変更を許していません。また、変化する環境の値（たとえば現在時刻）を式の中で読み込むこともできません。
#       
#       これによって、ある式をいつどこで評価しても、必ず同じ結果が得られること（参照透過性）が保証されています。
# 
#       この性質は意図しない結果を生じさせないためには望ましいものですが、これでは困るケースもあります。
# 
#       （TODO たとえば？）
# 
#       ### `do` 式

